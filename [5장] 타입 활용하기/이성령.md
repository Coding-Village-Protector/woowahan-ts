# 5장. 타입 활용하기

> 타입스크립트의 기본적인 문법과 react, react-query의 활용법

<details>
  <summary>목차</summary>
  <ul markdown="1">
    <li><a href="#51-조건부-타입">5.1 조건부 타입</a></li>
    <li><a href="#52-템플릿-리터럴-타입-활용하기">5.2 템플릿 리터럴 타입 - 활용하기</a></li>
    <li><a href="#53-커스텀-유틸리티-타입-활용하기">5.3 커스텀 유틸리티 - 타입 활용하기</a></li>
    <li><a href="#54-불변-객체-타입으로-활용하기">5.4 불변 객체 타입으로 활용하기</a></li>
    <li><a href="#55-record-원시-타입-키-개선하기">5.5 record 원시 타입 키 개선하기</a></li>
  </ul>
</details>
<br />

## 5.1 조건부 타입

타입스크립트의 조건부 타입은 자바스크립트의 삼항 연산자와 동일한 형태를 가진다.

```tsx
Condition ? A : B;
// Condition이 true일 때 A 타입
// Condition이 false일 때 B 타입
```

조건부 타입을 활용하면 얻을 수 있는 **장점**

- **중복되는 타입 코드를 제거** 가능
- 상황에 따라 적절한 타입을 얻을 수 있기에 **더욱 정확한 타입 추론**이 가능

아래는 어떤 상황에서 조건부 타입이 필요한지, 조건부 타입을 적용함으로써 어떤 장점을 얻을 수 있는지 알아본다.

<br />

### (1) extends와 제네릭을 활용한 조건부 타입

타입스크립트에서 다양한 상황에서 활용되는 **`extends`**

- [타입을 확장할 때](https://github.com/Coding-Village-Protector/woowahan-ts/blob/main/%5B4%EC%9E%A5%5D%20%ED%83%80%EC%9E%85%20%ED%99%95%EC%9E%A5%ED%95%98%EA%B8%B0%C2%B7%EC%A2%81%ED%9E%88%EA%B8%B0/%EA%B0%95%EC%A7%80%EC%9C%A4.md#41-%ED%83%80%EC%9E%85-%ED%99%95%EC%9E%A5%ED%95%98%EA%B8%B0)
- **타입을 조건부로 설정할 때** 👈 지금
- [제네릭 타입에서 한정자 역할로 사용할 때](https://github.com/Coding-Village-Protector/woowahan-ts/blob/main/%5B3%EC%9E%A5%5D%20%EA%B3%A0%EA%B8%89%20%ED%83%80%EC%9E%85/%EC%9D%B4%EC%98%88%EC%86%94.md#%EC%A0%9C%ED%95%9C%EB%90%9C-%EC%A0%9C%EB%84%A4%EB%A6%AD)

```tsx
T extends U ? X : Y
// 타입 T를 U에 할당할 수 있으면 X 타입
// 타입 T를 U에 할당할 수 없으면 Y 타입
```

```tsx
interface Bank {
  financialCode: string;
  fullName: string; // Card와의 차이
}
interface Card {
  financialCode: string;
  appCardType?: string; // Bank와의 차이
}
type payMethod<T> = T extends "card" ? Card : Bank; // 제네릭 타입으로 extends를 사용한 조건부 타입
type CardPayMethodType = PayMethod<"card">; // 제네릭 매개변수 = "card" : Card 타입
type BankPayMethodType = PayMethod<"bank">; // 제네릭 매개변수 != "card" : Bank 타입
```

<br />

### (2) 조건부 타입을 사용하지 않았을 때의 문제점

> ⚠️ (2)(3)챕터에 한해 책 설명만으로 충분치 않아 ChatGPT의 도움을 받아 이해한 내용을 토대로 정리했습니다. 때문에 책과는 세부 설명이 다름을 명시합니다. [ChatGPT 질문지 전문](https://chat.openai.com/share/dc353d0e-7085-4a81-a1ae-677004e5dadc)

React-Query + TypeScript 프로젝트의 일부인 아래 코드를 보면서 문제를 파악해보자.

계좌(bank), 카드(card), 앱카드(appcard) 3가지 결제 수단이 있다. 아래 코드는 주어진 결제 수단 타입(`type`)을 서버 응답을 처리하는 공통 함수(`useGetRegisteredList`)에 전달. 각 API를 통해 결제 수단 정보를 배열로 받아와 최종적으로 필터링된 배열(`result`)을 반환하는 코드다.

```tsx
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;

export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[]> => {
  const url = `baeminpay/codes/${type === "appcard" ? "card" : type}`;
  const fetcher = fetcherFactory<PayMethodType[]>({
    onSuccess: (res) => {
      const usablePocketList =
        res?.filter(
          (pocket: PocketInfo<Card> | PocketInfo<Bank>) =>
            pocket?.useType === "USE"
        ) ?? [];
      return usablePocketList;
    },
  });
  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);

  return result;
};
```

개발자는 `useGetRegisteredList`가 인자의 타입으로 "card", "appcard", "bank" 중 하나를 받아 해당 타입과 알맞은 타입으로 반환까지 해내기를 원했다.

- "card", "appcard" => `Card`
- "bank" => `Bank`

때문에 타입 `PayMethodType`을 `Card` 또는 `Bank` 타입의 `PatMethodInfo` 중 하나로 고정하고 반환값 `result`에 `PayMethodType[]` 타입을 명시해주었다. 하지만 `Card`와 `Bank` 를 명확히 구분하는 로직이 없다. 이것이 문제가 된다.

사용자가 인자로 "card"를 전달했을 때 함수가 반환하는 타입이 `PayMethodInfo<Card>[]`였으면 좋겠지만, 타입 설정이 유니온(`|`)으로만 되어있기 때문에 구체적으로 추론할 수 없다.

즉, `useGetRegisteredList`는 인자로 넣는 타입에 알맞은 타입을 반환하지 못하는 함수다. 유니온 외 다른 조치가 필요하다.

<br />

### (3) extends 조건부 타입을 활용하여 개선하기

extends **조건부 타입**을 활용하여 하나의 API 함수에서 타입에 따라 정확한 반환 타입을 추론하게 만들 수 있다. 또한 extends를 **제네릭의 확장자**로 활용해서 `card`, `appcard`, `bank` 외 다른 값이 인자로 들어오는 경우도 방어한다.

```tsx
// before
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;

// after
type PayMethodType<T extends "card" | "appcard" | "bank"> = T extends
  | "card"
  | "appcard"
  ? Card
  : Bank;
// PayMethod의 제네릭으로 받은 값이 "card" 또는 "appcard"면 PayMethodInfo<Card> 타입을 반환
// PayMethod의 제네릭으로 받은 값이 이외의 값이면 PayMethodInfo<Bank> 타입을 반환
```

새롭게 정의한 `PayMethodType`에 제네릭 값을 넣어주기 위해 `useGetRegisteredList` 함수 인자의 타입을 넣어준다.

```tsx
// before
export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[]> => {
  /* ... */
  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);
  return result;
};

// after
export const useGetRegisteredList = <T extends "card" | "appcard" | "bank">(
  type: T
): UseQueryResult<PayMethodType<T>[]> => {
  /* ... */
  const result = useCommonQuery<PayMethodType<T>[]>(url, undefined, fetcher);
  return result;
};
```

이렇게 조건부 타입을 활용함으로써

- 인자로 "card" 또는 "appcard"를 받으면 `PayMethodInfo<Card>`를 반환하고
- 인자로 "bank"를 받으면 `PayMethodInfo<Bank>`를 반환한다.

이에 따라 불필요한 타입 가드와 불필요한 타입 단언을 하지 않아도 된다.

<br />

**타입 확장 외 extends 활용 예시 재정리**

- 제네릭과 extends를 함께 사용해 제네릭으로 받는 타입을 제한하는 한정자 역할 => 개발자가 잘못된 값을 넘기는 휴먼에러를 방지
- extends를 활용한 조건부 타입 설정 => 반환 값을 사용자가 원하는 값으로 구체화. 불필요한 타입 가드, 타입 단언 방지

<br />

### (4) infer를 활용해서 타입 추론하기

extends를 사용할 때 `infer` 키워드 사용. extends로 조건을 서술하고 infer로 타입을 추론

```tsx
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
// Promise<infer K> : Promise의 반환 값을 추론해 해당 값의 타입을 K라고 지정

const promises = [Promise.resolve("Mark"), Promise.resolve(38)];
type Expected = UnpackPromise<typeof promises>; // string | number
```

<!-- 라이더 어드민 예제 가능하면 추가 -->

<br />

## 5.2 템플릿 리터럴 타입 활용하기

타입스크립트에서는 유니온 타입을 사용해서 변수 타입을 특정 문자열로 지정할 수 있었다. (휴먼 에러 방지 및 자동 완성 기능을 통한 개발 생산성 향상 등 장점 보유)

```tsx
type HeaderTag = "h1" | "h2" | "h3" | "h4" | "h5";
```

타입스크립트 4.1부터 이를 확장하는 방법인 **템플릿 리티럴 타입(Template Literal Type)** 을 지원한다.

```tsx
type HeadingNumber = 1 | 2 | 3 | 4 | 5;
type HeaderTag = `h${HeadingNumber}`;
```

```tsx
type Vertical = "top" | "bottom";
type Horizon = "left" | "right";

type Direction = Vertical | `${Vertical}${Capitalize<Horizon>}`;
// "top" | "topLeft" | "topRight" | "bottom" | "bottomLeft" | "bottomRight"
```

- 장점
  - 더욱 읽기 쉬운 코드 작성 가능하다.
  - 코드를 재사용하고 수정하는 데 용이한 타입 선언 가능하다.
- 주의할 점
  - 타입스크립트 컴파일러가 유니온을 추론하는 데 시간이 오래 걸리면 에러를 내뱉기 때문에 조합 경우의 수가 너무 많지 않도록 나누어서 타입 정의를 권장

<br />

## 5.3 커스텀 유틸리티 타입 활용하기

타입스크립트에서 제공하는 유틸리니 타입만으로 표현하기에는 한계가 있는 경우 **커스텀 유틸리티 타입**을 제작해서 사용한다.

<br />

### (1) 유틸리티 함수를 활용해 styled-components의 중복 타입 선언 피하기

컴포넌트의 background-color, size 값 등을 props로 받아와서 상황에 따라 스타일을 구현하는 경우와 같이, 스타일 관련 props를 styled-components에 전달하려면 타입을 정확하게 작성해줘야 한다. 이 경우 타입스크립트에서 제공하는 **`Pick`, `Omit`** 과 같은 유틸리티 타입을 활용한다.

```tsx
// HrComponent.tsx
export type Props = {
  height?: string;
  color?: keyof typeof colors;
  isFull?: boolean;
  className?: string;
};

export const Hr: VFC<Props> = ({ height, color, isFull, className }) => {
  /* ... */
  return (
    <HrComponent
      height={height}
      color={color}
      isFull={isFull}
      className={className}
    />
  );
};
```

위 예제에서 `HrComponent`는 styled-component인데 `height`, `color`, `isFull`을 props로 받아 스타일링에 사용하려고 한다. `Hr`에 사용된 타입 Props와 타입 중 일부를 사용하니 `Pick`을 이용해 새로 정의한 `StyledProps` 를 사용하면 **중복된 코드를 작성하지도 않아도 되고 유지보수를 편하게 할 수 있다.**

```tsx
// style.ts
import { Props } from '../HrComponent.tsx';

// 타입 Props에서 스타일링에 필요한 속성만 골라냄 (cf. "className")
type StyledProps = Pick<Props, "height" | "color" | "isFull">;

const HrComponent = styled.hr<StyledProps>`
  height: ${({ height }) = > height || "10px"};
  margin: 0;
  background-color: ${({ color }) = > colors[color || "gray7"]};
  border: none;
  ${({ isFull }) => isFull && css`
    margin: 0 -15px;
  `}
`;
```

<br />

### (2) PickOne 유틸리티 함수

타입스크립트에는 서로 다른 2개 이상의 객체를 유니온 타입으로 받을 때 타입 검사가 제대로 되지 않는 이슈가 있다. 이 문제를 해결하기 위한 유틸리티 함수 **PickOne**을 구현하는 예제다.

```tsx
type Card = {
  card: string;
};
type Account = {
  account: string;
};
function withdraw(type: Card | Account) {
  /* ... */
}
withdraw({ card: "hyundai", account: "hana" }); // 에러 없음
```

위 예제에서 `Card`, `Account`는 [집합 관점에서 합집합이기 때문에](https://github.com/Coding-Village-Protector/woowahan-ts/blob/main/%5B4%EC%9E%A5%5D%20%ED%83%80%EC%9E%85%20%ED%99%95%EC%9E%A5%ED%95%98%EA%B8%B0%C2%B7%EC%A2%81%ED%9E%88%EA%B8%B0/%EA%B0%95%EC%A7%80%EC%9C%A4.md#412-%EC%9C%A0%EB%8B%88%EC%98%A8-%ED%83%80%EC%9E%85) withdraw 함수의 인자는 `{ card: "hyundai" }`와 `{ account: "hana" }`를 모두 받아도 타입 에러가 발생하지 않는다.

<br />

이 문제를 해결하기 위해서는 [식별할 수 있는 유니온](https://github.com/Coding-Village-Protector/woowahan-ts/blob/main/%5B4%EC%9E%A5%5D%20%ED%83%80%EC%9E%85%20%ED%99%95%EC%9E%A5%ED%95%98%EA%B8%B0%C2%B7%EC%A2%81%ED%9E%88%EA%B8%B0/%EA%B0%95%EC%A7%80%EC%9C%A4.md#43-%ED%83%80%EC%9E%85-%EC%A2%81%ED%9E%88%EA%B8%B0---%EC%8B%9D%EB%B3%84%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%9C%A0%EB%8B%88%EC%98%A8discriminated-unions)을 자주 활용한다.

/_ 여기서부터 이어서 작성 p.167 _/

<br />

### (3) NonNullable 타입 검사 함수를 사용하여 간편하게 타입 가드하기

<br />

## 5.4 불변 객체 타입으로 활용하기

<br />

### (1) Atom 컴포넌트에서 theme style 객체 활용하기

<br />

## 5.5 Record 원시 타입 키 개선하기

<br />

### (1) 무한한 키를 집합으로 가지는 Record

<br />

### (2) 유닛 타입으로 변경하기

<br />

### (3) Partial을 활용하여 정확한 타입 표현하기
